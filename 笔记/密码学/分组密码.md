异或性质:

在 % 2 空间下可以提取，

相当于选取了某一些行，让所有元素异或，提取出来一样正确。

(B * A) ${\oplus}$ (B * C) = B ${*}$ (A ${\oplus}$ C)

首先这个式子在mod 2下成立，所以对所有矩阵先mod 2

得到只含0 1的矩阵，B * A所作的，B第 i 行非零元素，非零元素所在的列记作C ，选取A的某一列 j

若 k 属于 C，且 sum_ XOR  ( ${A_{kj}}$ ) == 1 ，若 sum_ XOR  ( ${A_{kj}}$ ) == 1 ，则 ${C_{ij}}$ = 1，else = 0

所以本质上就是统计A矩阵在某一列的属于C的行的非零元个数。奇数为1，偶数为0，相当于作异或。

所有运算都转化为异或，再稍加推导，不难看出性质成立。

 



![image-20231101124633589](C:\Users\Haon\AppData\Roaming\Typora\typora-user-images\image-20231101124633589.png)

如何通过 120 对输入输出，破解密码

B * D = C

B是上述矩阵，D是我们的输入向量，C是密文。

首先明确一个问题，轮密钥是线性的，所以每一位是原来密钥的位置转换。

D[M , K]

D向量由m和原密钥组成，其实如果S盒线性，那么密文的每一位不过是M的某些位和K的某些位做了异或操作得来的，

那么D共 m + k 行，即64 + 56 = 120 行，分别取某一行为1，其余行为0，进行加密，得到密文，如果密文某位为1，则证明B矩阵必然存在1，这个1的位置行对应 C中为1的行，列对应D矩阵设置为1的列。通过一次设置密钥，就可以还原B的某一列，经过120次操作即可换元B矩阵，B矩阵还原出，作逆运算即可得到D矩阵。



##### 模式

#####  E C B 模式

将明文切片为分组密钥长度，然后分别加密，得到密文。

不建议使用！

优点 简单，高效，支持并行加密解密。

缺点

- 明文切片相同部分会反应为相同的密文。
- 通过对于密文的替换，删除对明文操纵（用户设置用户名，密码。如果用户名和密码分为两个切片，那么攻击者篡改，将密码的密文覆盖为用户名的密文，那么在系统收到密文，就会设置用户的密码为用户名，然而用户名为密码，攻击者十分容易得到或者猜测，丧失安全性。）

替换攻击



##### C B C 模式

有一个初始序列，每次和明文异或之后进行加密得到密文，然后密文再和下一个明文异或之后加密得到密文.......

优点 

- 明文的重复不会反应在密文。
- 支持并行解密。 （已经知道了所有密文）
- 可以解密任意密文分组。 无需按序。

缺点

-   密文比特错误会导致连锁无法解密。
-   加密不能并行

初始向量某一位反转，可以操纵明文某一位反转。解密最后一步是初始向量和解密后的信息异或，只要反转初始向量，最后明文的结果也会反转。





##### C F B 模式

初始序列加密后和明文异或得到密文，然后密文加密后和下一明文异或得到密文。

优点

- 解密可并行
- 解密无序性，只需前一个密文加密再与当前密文异或即可解密

缺点

- 加密无法并行
- 比特错误的泛滥
- 重放攻击，修改密文直接影响明文。

可以对密文替换，从而篡改掉明文的内容。因为序列再不更改的情况下，到达某个明文加密的密钥是相等的，

将该部分之后的密文整体迁移，就可以替换后面的明文内容。必须后面整体缓过来，因为密钥列变了，密文列也要对应。

##### O F B 模式

由初始序列加密不断生成密钥流，然后与明文异或。

- 可事先准备好密钥流
- 并行性更好


缺点

​    反正密文即可操纵明文。

​    某一输出序列，输入等于输出，后面的密钥完全相同。



##### C T R 模式

只有后面的计数为改变，根据要加密的数据块序号，即可确认密钥，进行加密

支持全并行

缺点 

​     密文反转造成铭文反转

















