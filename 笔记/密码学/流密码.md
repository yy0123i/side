#### 1 PRG安全

##### 1.1PRG 随机序列发生器

k不足够长，利用PRG可以理解成一个函数，G，经过G(k) = output ,output是一个比较长的序列可以作为实际密钥使用。发生器的随机性需要进行验证，一个好的发生器决定密码算法的安全性。

##### 1.2 统计测试

有如下方法，可以任意选用。给定发生器A，并记录统计都可以算作统计测试。
$$
0的数量与1的数量 差值的绝对值 < 10sqrt(n)
$$

$$
|00的数量 - n / 4|<10*\sqrt{n}
$$

$$
0的最大连续长度||1的最大连续长度 < log_2n
$$

##### 1.3 优势 

用于评价一个统计测试是否能够很好的检验序列的随机性

能否找到伪随机序列和随机序列在某种性质上的差异 这种差异就体现在GR的值上。

A发生器 G随机序列生成器 
$$
GR = |Pr(A(G(k)) == 1) - Pr(A(r) == 1)|
$$

##### 1.4 安全PRG

A 代表统计测试

安全PRG有如下理解:

if not ${\exist}$ 有效的A，使得${GR > \xi}$  

$ {\forall}$ 有效的A，使得${GR -> 0}$

P = NP => 很容易证明不存在安全的PRG

如果能证明一个PRG是安全的 => P不等于NP



##### 1.5安全定义应用

给定前 i 位可以一定概率预测 i+1 位认为不安全

证明:(从优势角度评判)

${Pr(A(G(k)_{1...i}) == G(k)|_{i+1}) > 1/2 + {\xi}}$

因为简单猜测0 1的概率为1/2，如果根据前i位能推出后一位的概率> 1/2+${\xi}$   则认为是可预测的

B(x) = if A == ${G_{i+1}}$  = 1 else 0

那么GR = |B(x) - 1/2| = ${\xi}$

如果 ${\xi}$ 足够大则认为不安全



##### 1.6 重要定理

如果和随机序列有差异则认为是不安全的 => 如果发生器不安全，那么存在l可以完成预测

如果发生器不可预测对于任意l成立，那么发生器实际上是安全的



##### 小结

PRG安全则${if (k <-^{R}-K:G(k)) \,\,\,like\,\,\,\,uniform({0,1})^n  })$



#### 2 密码安全

##### 唯密文攻击

只知道密文下进行的攻击

##### 完善保密性

在唯密文攻击下，无论攻击者计算资源多么强大，都不可能获取关于明文的一点信息

![image-20231028110018483](C:\Users\Haon\AppData\Roaming\Typora\typora-user-images\image-20231028110018483.png)

![image-20231028110536169](C:\Users\Haon\AppData\Roaming\Typora\typora-user-images\image-20231028110536169.png)

归纳一句话: 对于任意密文，任意明文变成该密文对应的密钥数目相同。

一次一密：具有完善保密性，可以防止唯密文攻击。



##### 证明一次一密具备完善保密性

只需要证给定任意密文c，把每个明文加密成c对应的密钥数都为N

根据一次一密 c = k ^ m , k = m ^ c 可知在密文和明文确定的情况下，k是唯一确定的，所以任意明文加密成c对应的密钥数为1，即证明一次性密码本具备完善保密性，可以抗唯密文攻击。



##### 流密码为何不具备完善保密性

###### 香农定理

香农定理告诉我们，如果一个加密体制具有完善保密性，那么密钥数量至少要和明文数量一样多。 

证明:

对于每个k,都有一个明密文转换表，其中包括了所有明文，假设有两个明文经过一个k，得到同一个c，那么解密算法遇到c，利用这个k解密不会得到唯一结果，不满足唯一性的特性，所以某一个c只会在某一个明密文转换表中出现一次。那么设密钥空间为N，则对于每个明密文转换表，c最多出现一次，则有c的数量 < N，则该c对应的明文数，也一定 < N，记作M(c)。

反证法，M代表明文数量 ，若N < M ， 又知某个c存在M(c）< N，则有 M(c) < M

这个结论是说某个密文c只能由部分明文转换而来，那么根据完善保密性，对于任意c，由不同明文转换过来的概率相等，而此时存在某些明文转换为c的概率不为0，而某些转换为c的概率为0，矛盾，不符合完善保密性。

故 N >= M 证毕



###### 流密码 

流密码不具备完美安全性。

选择明文攻击（chosen-plaintext attack, CPA）：攻击者自己选择一些明文，并可以通过某些手段获得相应的密文。 



###### PRG安全模型（PRG安全性）

![image-20231028154223702](C:\Users\Haon\AppData\Roaming\Typora\typora-user-images\image-20231028154223702.png)



Adv = |Pr[w0] - Pr[w1]|

也就是说攻击者在实验0中猜测自己面对的是真随机序列的概率和在实验1中猜测自己面对的是真随机序列的概率相同，则证明PRG产生的序列对于攻击者来说无法区分真随机和伪随机，那么我就认为PRG是安全的。



###### PRG不可预测性

![image-20231028154558012](C:\Users\Haon\AppData\Roaming\Typora\typora-user-images\image-20231028154558012.png)



![image-20231028154819529](C:\Users\Haon\AppData\Roaming\Typora\typora-user-images\image-20231028154819529.png)



这种联系是存在的：PRG的安全性和不可预测性其实是等价。

如果一个PRG是安全的，它一定是不可预测的；反之，如果一个PRG是不可预测的，它一定是安全的。





引入语义安全

![image-20231028152729946](C:\Users\Haon\AppData\Roaming\Typora\typora-user-images\image-20231028152729946.png)

攻击者发送两个不同的明文m0，m1。挑战者在密钥空间选择k，加密m0或m1返还给攻击者，此时攻击者判断这个密文是加密m0的结果还是加密m1的结果。如果可以区分出该密文属于m0的加密还是m1的加密，那么攻击者对于任意一个密文进行分析，可以区分出它是m0的加密结果或者是m1的加密结果，那么就会导致信息的泄露。只有判断正确率趋于1/2才保证了语义的安全性。



###### 定理证明: PRG安全，则语义安全

令EXP(0)为r，EXP(1)为G(k)，同样都只加密m0，由定义可知PRG安全，那么优势为0，则EXP(0)和EXP(1)不可区分

同理令EXP(2)为r，EXP(3)为G(k)，同样只加密m1，则EXP(2)和EXP(3)不可区分

EXP(0)和EXP(2)都为r，一个加密m0，一个加密m1，由一次密码本性质，优势为0，所以EXP(0) 与 EXP(2) 不可区分

有

EXP(0) 和 EXP(1)

EXP(2) 和 EXP(3)

EXP(0) 与 EXP(2) 

得EXP(1)和EXP(3)不可区分，即证明了语义安全性。
